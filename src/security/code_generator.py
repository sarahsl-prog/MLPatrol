"""Utility helpers for building ML security validation scripts.

This module centralizes the string-generation logic used by MLPatrol when it
needs to emit standalone Python scripts (e.g., via the `generate_security_code`
tool).  The helpers focus on two primary use cases:

1. General environment validation (is a dependency present + patched?)
2. CVE-focused validation (does the environment contain a vulnerable build?)

Each helper returns a fully formatted Python script that can be written to disk
or streamed back to the user.
"""

from __future__ import annotations

import keyword
import re
from textwrap import dedent
from typing import List, Optional


def _sanitize_identifier(name: str) -> str:
    sanitized = re.sub(r"\W+", "_", name).strip("_").lower()
    if not sanitized:
        sanitized = "library"
    if sanitized[0].isdigit():
        sanitized = f"lib_{sanitized}"
    return sanitized


def _escape_docstring_text(value: str) -> str:
    if not value:
        return "Security validation"
    return value.replace('"""', '\"\"\"').strip()


def _can_direct_import(name: str) -> bool:
    return name.isidentifier() and not keyword.iskeyword(name)


def _direct_import_statement(library: str, alias: str) -> str:
    if _can_direct_import(library):
        return f"import {library} as {alias}\n\n"
    return ""


def _version_helper_block() -> str:
    return dedent(
        """
        def _is_version_greater_or_equal(current: str, reference: str) -> bool:
            \"\"\"Compare two version strings with graceful degradation.\"\"\"
            try:
                from packaging import version as _version_parser  # type: ignore
                return _version_parser.parse(current) >= _version_parser.parse(reference)
            except Exception:
                def _coerce(value: str) -> tuple[int, ...]:
                    parts: list[int] = []
                    for token in value.replace('-', '.').split('.'):
                        if token.isdigit():
                            parts.append(int(token))
                    return tuple(parts)

                return _coerce(current) >= _coerce(reference)
        """
    )


def _build_common_header(library: str, purpose: str, cve_id: Optional[str], alias: str) -> str:
    purpose_text = _escape_docstring_text(purpose)
    doc_lines = [
        '"""',
        f"Security Validation Script: {purpose_text}",
        f"Target Library: {library}",
    ]
    if cve_id:
        doc_lines.append(f"CVE: {cve_id}")
    doc_lines.extend(["", "Generated by MLPatrol Security Agent", '"""'])
    docstring = "\n".join(doc_lines)

    import_block = _direct_import_statement(library, alias)

    return dedent(
        f"""#!/usr/bin/env python3
        {docstring}

        from __future__ import annotations

        import argparse
        import importlib
        import importlib.metadata
        import sys
        from typing import List, Optional, Sequence, Tuple

        {import_block}PACKAGE_NAME = "{library}"
        SCRIPT_PURPOSE = "{purpose_text}"
        """
    )


def _build_module_resolver(alias: str, library: str) -> str:
    return dedent(
        f"""
        def _resolve_target_library():
            try:
                return {alias}
            except NameError:
                return importlib.import_module("{library}")
        """
    )


def build_general_security_script(
    purpose: str,
    library: str,
    affected_versions: Optional[List[str]] = None,
) -> str:
    identifier = _sanitize_identifier(library)
    alias = f"_mlpatrol_{identifier}_module"
    header = _build_common_header(library, purpose, None, alias)

    function_name = f"check_{identifier}_security"
    versions_literal = affected_versions or []

    body = dedent(
        f"""
        {_version_helper_block()}

        def _get_installed_version(package_name: str) -> str:
            try:
                return importlib.metadata.version(package_name)
            except importlib.metadata.PackageNotFoundError as exc:  # pragma: no cover - runtime failure
                raise RuntimeError(f"{{package_name}} is not installed") from exc


        {_build_module_resolver(alias, library)}

        def {function_name}(min_version: Optional[str] = None) -> Tuple[bool, str]:
            \"\"\"Validate that the target library is present and optionally patched.\"\"\"
            module = _resolve_target_library()
            installed_version = _get_installed_version(PACKAGE_NAME)
            report_lines = [
                f"Library: {{PACKAGE_NAME}}",
                f"Detected version: {{installed_version}}",
                f"Purpose: {{SCRIPT_PURPOSE}}",
            ]

            known_vulnerable_versions = {versions_literal}

            if known_vulnerable_versions and installed_version in known_vulnerable_versions:
                report_lines.append("⚠️  Installed version is on the vulnerable allowlist.")
                return False, "\\n".join(report_lines)

            if min_version:
                if _is_version_greater_or_equal(installed_version, min_version):
                    report_lines.append(f"Version meets minimum requirement {{min_version}}.")
                else:
                    report_lines.append(
                        f"⚠️  Version {{installed_version}} is below the required minimum {{min_version}}."
                    )
                    return False, "\\n".join(report_lines)

            if not hasattr(module, "__version__"):
                report_lines.append("Note: module does not expose __version__; keep manual monitoring enabled.")

            return True, "\\n".join(report_lines)


        def _parse_args() -> argparse.Namespace:
            parser = argparse.ArgumentParser(
                description="Validate that required ML libraries are installed and up to date."
            )
            parser.add_argument(
                "--min-version",
                dest="min_version",
                help="Minimum acceptable version (inclusive).",
                default=None,
            )
            return parser.parse_args()


        def main() -> int:
            args = _parse_args()
            try:
                is_secure, message = {function_name}(args.min_version)
            except Exception as exc:  # pragma: no cover - runtime safety
                print(f"[ERROR] {{exc}}", file=sys.stderr)
                return 2

            print("=" * 70)
            print(message)
            print("=" * 70)
            return 0 if is_secure else 1


        if __name__ == "__main__":
            sys.exit(main())
        """
    )

    return dedent(f"{header}\n{body}")


def build_cve_security_script(
    purpose: str,
    library: str,
    cve_id: Optional[str],
    affected_versions: Optional[List[str]],
) -> str:
    identifier = _sanitize_identifier(library)
    alias = f"_mlpatrol_{identifier}_module"
    header = _build_common_header(library, purpose, cve_id, alias)
    function_name = f"check_{identifier}_security"
    versions_literal = affected_versions or []

    body = dedent(
        f"""
        {_version_helper_block()}

        VULNERABLE_VERSIONS: List[str] = {versions_literal}
        CVE_ID = "{cve_id or 'UNKNOWN'}"


        def _get_installed_version(package_name: str) -> str:
            try:
                return importlib.metadata.version(package_name)
            except importlib.metadata.PackageNotFoundError as exc:
                raise RuntimeError(f"{{package_name}} is not installed; install patched releases immediately.") from exc


        {_build_module_resolver(alias, library)}

        def {function_name}(
            safe_version: Optional[str] = None,
            override_vulnerable_versions: Optional[Sequence[str]] = None,
        ) -> Tuple[bool, str]:
            \"\"\"Check whether the current installation is impacted by the tracked CVE.\"\"\"
            _resolve_target_library()  # ensure module can be imported
            installed_version = _get_installed_version(PACKAGE_NAME)
            vulnerable_versions = list(override_vulnerable_versions or VULNERABLE_VERSIONS)

            report_lines = [
                f"Library: {{PACKAGE_NAME}}",
                f"Detected version: {{installed_version}}",
                f"Tracked CVE: {{CVE_ID}}",
            ]

            if vulnerable_versions and installed_version in vulnerable_versions:
                report_lines.append("⚠️  Installed version matches known vulnerable releases.")
                return False, "\\n".join(report_lines)

            if safe_version and not _is_version_greater_or_equal(installed_version, safe_version):
                report_lines.append(
                    "⚠️  Installed version predates the known safe baseline "
                    f"({{safe_version}}). Upgrade is required."
                )
                return False, "\\n".join(report_lines)

            report_lines.append("✅ No known vulnerable signatures detected.")
            return True, "\\n".join(report_lines)


        def _parse_args() -> argparse.Namespace:
            parser = argparse.ArgumentParser(
                description="Detect whether the current environment is impacted by a specific CVE."
            )
            parser.add_argument(
                "--safe-version",
                dest="safe_version",
                help="Version that contains the vendor patch/fix.",
                default=None,
            )
            parser.add_argument(
                "--override-vulnerable-versions",
                nargs="*",
                help="Space separated list of versions to treat as vulnerable.",
                default=None,
            )
            return parser.parse_args()


        def main() -> int:
            args = _parse_args()
            try:
                is_safe, message = {function_name}(args.safe_version, args.override_vulnerable_versions)
            except Exception as exc:  # pragma: no cover - runtime safety
                print(f"[ERROR] {{exc}}", file=sys.stderr)
                return 2

            print("=" * 70)
            print(message)
            print("=" * 70)
            return 0 if is_safe else 1


        if __name__ == "__main__":
            sys.exit(main())
        """
    )

    return dedent(f"{header}\n{body}")


def build_security_script(
    purpose: str,
    library: str,
    cve_id: Optional[str] = None,
    affected_versions: Optional[List[str]] = None,
) -> str:
    """Convenience wrapper that selects the right template automatically."""
    if cve_id or "cve" in (purpose or "").lower():
        return build_cve_security_script(purpose, library, cve_id, affected_versions)
    return build_general_security_script(purpose, library, affected_versions)
# Code Generator 
